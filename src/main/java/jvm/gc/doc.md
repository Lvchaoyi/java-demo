即时编译器类型
Person.java源码文件是Java这门高级开发语言，对程序员友好，方便我们开发。javac编译器将Person.java源码文件编译成class文件[我们把这里的编译称为前期编译]，交给JVM运行，因为JVM只能认识class字节码文件。同时在不同的操作系统上安装对应版本的JDK，里面包含了各自屏蔽操作系统底层细节的JVM，这样同一份class文件就能运行在不同的操作系统平台之上，得益于JVM。这也是Write Once，Run Anywhere的原因所在。
最终JVM需要把字节码指令转换为机器码，可以理解为是0101这样的机器语言，这样才能运行在不同的机器上，那么由字节码转变为机器码是谁来做的呢？说白了就是谁来执行这些字节码指令的呢？这就是执行引擎。


解释执行
Interpreter，解释器逐条把字节码翻译成机器码并执行，跨平台的保证。刚开始执行引擎只采用了解释执行的，但是后来发现某些方法或者代码块被调用执行的特别频繁时，就会把这些代码认定为“热点代码”。
即时编译器
Just-In-Time compilation(JIT)，即时编译器先将字节码编译成对应平台的可执行文件，运行速度快。即时编译器会把这些热点代码编译成与本地平台关联的机器码，并且进行各层次的优化，保存到内存中。
JVM采用哪种方式
JVM采取的是混合模式，也就是解释+编译的方式，对于大部分不常用的代码，不需要浪费时间将其编译成机器码，只需要用到的时候再以解释的方式运行；对于小部分的热点代码，可以采取编译的方式，追求更高的运行效率。
即使编译器类型
（1）HotSpot虚拟机里面内置了两个JIT：C1和C2
C1也称为Client Compiler，适用于执行时间短或者对启动性能有要求的程序
C2也称为Server Compiler，适用于执行时间长或者对峰值性能有要求的程序
（2）Java7开始，HotSpot会使用分层编译的方式
也就是会结合C1的启动性能优势和C2的峰值性能优势，热点方法会先被C1编译，然后热点方法中的热点会被C2再次编译
AOT和Graal VM
AOT
在Java9中，引入了AOT(Ahead-Of-Time)编译器，即时编译器是在程序运行过程中，将字节码翻译成机器码。而AOT是在程序运行之前，将字节码转换为机器码
优势 ：这样不需要在运行过程中消耗计算机资源来进行即时编译
劣势 ：AOT 编译无法得知程序运行时的信息，因此也无法进行基于类层次分析的完全虚方法内联，或者基于程序 profifile 的投机性优化（并非硬性限制，我们可以通过限制运行范围，或者利用上一次运行的程序 profifile 来绕开这两个限制）
Graal VM
在Java10中，新的JIT编译器Graal被引入它是一个以Java为主要编程语言，面向字节码的编译器。跟C++实现的C1和C2相比，模块化更加明显，也更加容易维护。Graal既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现AOT编译。除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的，代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。